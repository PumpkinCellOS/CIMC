

             &&
     ,_____&&&_____,
    //             \\
   //               \\
   |  P u m p k i n  | 
   |                 | 
   \\    C e l l    //
    \\             //
     '\___________/'

   
     
====================================
-=-=-                          -=-=-
-=-=-=-  CIMC Arch (16-bit)  -=-=-=-
-=-=-                          -=-=-
====================================



   Software Developer's Manual
   
           Version 1.0
   
   
   Copyright (c) SyberMCd 2020-2021
   Copyright (c) Adam2004yt 2021
   
   
   Prototype built by:
    Adam2004yt
    PumpkinCell
    SyberMCd



====================================

    
   
   ===== SHORTCUTS =====



Op - Opcode (Operation Code)
Mm - Mnemonic (in assembly)
Args - Arguments (in assembly)
AddB - Additional Byte (used for storing operation argument)
C++ - Instruction representation in C++ language

ia - Instruction Address



   ===== PHYSICAL ARCHITECTURE =====

   
   
-- Instruction Loader --

           ,-----,
    Ack  --|     |    
    D0   --|     | 
    D1   --|     | 
    D2   --|     | 
    D3   --|     | 
    D4   --|     |  [TODO]
    D5   --|     | 
    D6   --|     | 
    D7   --|     | 
    Rq   --|     | 
    RqOn --|     | 
           '-----'



   ===== PROCESS =====



-- CPU Cycle --

See Control-Unit.mod



   ===== INTERRUPTS =====



-- Internal Interrupts --

If an interrupt is called, the registers are placed
on stack in the following order:

 PUSH16 ip
 PUSH8 flags
 [PUSH16 arg]

'arg' is a 16-bit value which gives additional
information about interrupt.
If IRET is called, these registers are popped from
the stack in the reverse order. The arg must be
popped manually by operating system.

 [POP16 arg] // done by OS
 POP8 flags
 POP16 ip

No  Id    Arg  Mm    Purpose
---------------------------------------------------
0   INT0  no   #IM   Invalid Math Operation
1   INT1  no   #II   Invalid Instruction
2   INT2  no   #R1   Reserved
3   INT3  yes  #R2   Reserved (arg is ignored)
4   INT4  no   #R3   Reserved
5   INT5  yes  #R4   Reserved (arg is ignored)
6   INT6  no   #U1   User Accesible #1
7   INT7  no   #U2   User Accesible #2
---------------------------------------------------
8   IRQ0  no   #IQ0  Device Interrupt #0
9   IRQ1  no   #IQ1  Device Interrupt #1
10  IRQ2  no   #IQ2  Device Interrupt #2
11  IRQ3  no   #IQ3  Device Interrupt #3
12  IRQ4  no   #IQ4  Device Interrupt #4
13  IRQ5  no   #IQ5  Device Interrupt #5
14  IRQ6  no   #IQ6  Device Interrupt #6
15  IRQ7  yes  #IQ7  Cascaded Interrupt (reserved)
---------------------------------------------------

The User Accessible Interrupts can be called using an INT instruction.

The Cascaded Interrupt is reserved for scalability.

See Control-Unit.mod for further information.



   ===== REGISTERS =====



-- General-Purpose Registers --

Mm  Size Notes         MSB 0      4      8 LSB
ax  16b  Accumulator       [[-ah-] [-al-]]
bx  16b  Base              [[-bh-] [-bl-]]
cx  16b  Counter           [[-ch-] [-cl-]]
dx  16b  Data              [[-dh-] [-dl-]]
sp  16b  Stack pointer
bp  16b  Base pointer
// TODO: some basics of vm
// TODO: cycle counting ??


-- Control Registers --

Mm  Size Notes
ip  16b  Instruction Pointer
fl  8b   Flags
ivt 8b   Interrupt Vector Table Pointer


-- Flags Register --

xxxxxxxx
   NZOGI

I(Interrupt) G(Greater) O(Overflow) Z(Zero) N(In Interrupt)


-- Internal CU Registers --

These registers are not accesible by user.

Mm    Size  Notes
addb  2b    Additional 2 bytes needed flag
 * 00 - Not needed     N
 * 01 - 1 Byte needed  1
 * 10 - 2 Bytes needed 2
 * 11 - Not checked    3

   

   ===== ASSEMBLY =====


   
-- Detailed Description --

----------------------------------------------
OUT16 a, b -> 16-bit Output to Port
 C++  out16(a, b); // a-port, b-value
 
Reserved Opcode Range: /3 (32 insn)
x = port number (16x)

Op  Mm     Args      AddB
0x  OUT16  ax -> *x  N

----------------------------------------------
OUT8 a, b -> 8-bit Output to Port
 C++  out8(a, b); // a-port, b-value
 
Reserved Opcode Range: /3 (32 insn)
x = port number (16x)

Op  Mm     Args      AddB
1x  OUT8   al -> *x  N
 
----------------------------------------------
IN16 a, b -> 16-bit Input from Port
 C++  b = in16(a)
 
Reserved Opcode Range: /4 (16 insn)
x = port number (16x)

Op  Mm    Args      AddB
2x  IN16  ax <- *x  2(b)
 
----------------------------------------------
MOV a, b -> Move Value from 'a' to 'b'
 C++  a = b;

Reserved Opcode Range: /4 (16 insn)
 
Op  Mm  Args       AddB
30  MOV ax <= bx   N
31  MOV ax <= dx   N
32  MOV bx <= ax   N
33  MOV bx <= dx   N
34  MOV cx <= ax   N
35  MOV cx <= dx   N
36  MOV dx <= ax   N
37  MOV dx <= bx   N
38  MOV dx <= mem  2(b)
39  MOV val <= dx  2(a)
3A  MOV mem <= dx  2(a)
3B  MOV *dx <= ax  N
3C  .. Reserved ..
3D  .. Reserved ..
3E  .. Reserved ..
3F  .. Reserved ..

----------------------------------------------
J*c a -> Jump Conditionally
 C++  if(...) eip = a;
 Jumps to 'a' if specific flags are set. Clears these flags.
 
Reserved Opcode Range: /5 (8 insn)

Op  Mm  Args  AddB  Notes               Alias
40  JMP ia    2(a)  Unconditional  
41  JZ  ia    2(a)  If ZF is set        JE
42  JG  ia    2(a)  If GF is set
43  JL  ia    2(a)  If OF is set
44  JNE ia    2(a)  If ZF/GF/OF is set
45  .. Reserved ..
46  .. Reserved ..
47  .. Reserved ..

----------------------------------------------
CMP a, b -> Compare Values 'a', 'b'
 C++  a ?? b;

Reserved Opcode Range: /5 (8 insn)

Op  Mm  Args       AddB
48  CMP ax =? dx
49  CMP bx =? dx
4A  CMP cx =? dx
4B  .. reserved ..
4C  CMP ax =? val  2(b)
4D  CMP bx =? val  2(b)
4E  CMP cx =? val  2(b)
4F  CMP dx =? val  2(b)

----------------------------------------------
PUSH a -> Push 'a' to Stack
 C++  push(..)
 
Reserved Opcode Range: /6 (4 insn)

Op  Mm     Args  AddB  Notes
50  PUSH   ax
51  PUSH   dx
52  PUSHA              All registries (ax,bx,cx,dx,sp,flags)
53  PUSH   val   2(a)

----------------------------------------------
POP a -> Pop from Stack to 'a'
 C++  pop(..)
 
Reserved Opcode Range: /6 (4 insn)

Op  Mm    Args  AddB  Notes
54  POP   ax
55  POP   dx
56  POPA              All registries (ax,bx,cx,dx,sp,flags)
57  POP   val   2(a)

----------------------------------------------
ADD a, b -> Add from 'a' to 'b'
 C++  a += b;

Reserved Opcode Range: /5 (8 insn)

Op  Mm  Args       AddB
58  ADD ax <+ val  2(b)
59  ADD ax <+ bx   
5A  ADD ax <+ dx
5B  ADD cx <+ val  2(b)
5C  ADD cx <+ bx   
5D  ADD cx <+ dx
5E  ADD sp <+ val  2(b)
5F  ADD bp <+ val  2(b)

----------------------------------------------
SUB a, b -> Subtract from 'a' to 'b'
 C++  a -= b;
 
Reserved Opcode Range: /6 (4 insn)

Op  Mm  Args       AddB
60  SUB ax <- val  2(b)
61  SUB ax <- bx   
62  SUB ax <- dx
63  SUB cx <- val  2(b)
64  SUB cx <- bx   
65  SUB cx <- dx
66  SUB sp <- val  2(b)
67  SUB bp <- val  2(b)

Sets:
 ZF if result == 0
 OF if result < 0 (result & 0x80 == 1)
 GF if result > 0

----------------------------------------------
MUL a, b -> Multiply from 'a' to 'b'
 C++  a *= b;
 Saves MSB -> DX, LSB -> AX
 
Reserved Opcode Range: /6 (4 insn)

Op  Mm  Args             AddB
68  MUL ax <* val %> dx  2(b)
69  MUL ax <* bx %> dx

----------------------------------------------
DIV a, b -> Divide from 'a' to 'b'
 C++  a /= b;
 Saves modulus (a %= b) to DX
 
Using the opcode always triggers INT0 if b == 0
Reserved Opcode Range: /7 (2 insn)

Op  Mm  Args                AddB
6A  DIV ax </ val %> dx  2(b)
6B  DIV ax </ bx %> dx

----------------------------------------------
AND a, b -> Byte AND from 'a' to 'b'
 C++  a &= b;
 
Reserved Opcode Range: /7 (2 insn)

Op  Mm  Args       AddB
6C  AND ax <& val  2(b)
6D  AND ax <& bx

----------------------------------------------
OR a, b -> Byte OR from 'a' to 'b'
 C++  a |= b;
 
Reserved Opcode Range: /7 (2 insn)

Op  Mm  Args       AddB
6E  OR  ax <| val  2(b)
6F  OR  ax <| bx

----------------------------------------------
NEG a -> Byte/Logic Negate 'a'
 C++  a = !a;
 
Reserved Opcode Range: /7 (2 insn)

Op  Mm  Args  Notes
70  NEG ax    Byte Negate
71  NOT ax    Logic Negate

----------------------------------------------
RET -> Return from Procedure
 C++  return; [ip = *sp; sp--;]
 
Reserved Opcode Range: /7 (2 insn)

Op  Mm   Notes
72  RET  
73  IRET Return from Interrupt; clears IIF

----------------------------------------------
CALL a -> Call Procedure
 C++  (*a)(); [*sp = ip; jmp(a);]
 
Reserved Opcode Range: /7 (2 insn)

Op  Mm   Args  AddB
74  CALL ia    2(a)
75  CALL ax    N

----------------------------------------------
LIVT a -> Load Interrupt Vector Table
 C++  ivt = a;
 
Reserved Opcode Range: /8 (1 insn)

IVT structure:

0    4    8        16     8+16*size 
+----+----+---------+---------+
|0000| Sz |  Adresses x Size  |
+----+----+---------+---------+

Op  Mm   Args  AddB
76  LIVT ia    2(a)

----------------------------------------------
DBG -> Debug Print
 C++  dbg();
 
Reserved Opcode Range: /8 (1 insn)

Note: If this instruction gets called in production
environment, it's considered an "Invalid Instruction".
The argument is used for debugging control unit and
is ignored.

Op  Mm   AddB
77  DBG  2(ignored)

----------------------------------------------
HLT a -> Halt Processor
 C++  hlt();
 
Reserved Opcode Range: /8 (1 insn)

Op  Mm
78  HLT

----------------------------------------------
EXT ... -> Extended Operations

These opcodes are used to add new operations
in the future. They are reserved in current
version of spec. Using them triggers "Invalid
Instruction" trap.

Reserved Opcode Range: /7 (2 insn)

Op  Mm   AddB
79  ...  1(...)
7A  ...  2(...)

----------------------------------------------
INT a -> Interrupt
 C++ int(a)

Reserved Opcode Range: /7 (2 insn)

Note: The user-callable interrupts are #U1 and #U2.

Op  Mm
7B  INT #U1

----------------------------------------------
NEG a -> Byte/Logic Negate 'a'
 C++  a = !a; a = -a
 
Reserved Opcode Range: /7 (2 insn)

Op  Mm  Args  Notes
7C  NEG ax    Logic Negate
7D  NOT ax    Arithmetic Negate

----------------------------------------------
STI a -> Set Interrupt Flag
 C++  if = true;
 
Reserved Opcode Range: /8 (1 insn)

Op  Mm
7E  STI

----------------------------------------------
CLI a -> Clear Interrupt Flag
 C++  if = false;
 
Reserved Opcode Range: /8 (1 insn)

Op  Mm
7F  CLI

----------------------------------------------
IN8 a, b -> 8-bit Input from Port
 C++  b = in8(a)
 
Reserved Opcode Range: /4 (16 insn)
x = port number (16x)

Op  Mm   Args
8x  IN8  al <- *x
 
----------------------------------------------
INC a -> Increment a
 C++  a++;
 
Reserved Opcode Range: /8 (1 insn)

Op  Mm
90  INC ax

----------------------------------------------
DEC a -> Decrement a
 C++  a--;
 
Reserved Opcode Range: /8 (1 insn)

Op  Mm
91  DEC ax

----------------------------------------------
XOR a, b -> Exclusive OR from 'a' to 'b'
 C++  a ^= b;
 
Reserved Opcode Range: /7 (2 insn)

Op  Mm   Args       AddB  Notes
92  XOR  ax <^ val  2(b)
93  XOR  ax <^ bx   N
94  XOR  ax <^ ax   N     Clear ax
95  XOR  bx <^ bx   N     Clear bx
96  XOR  cx <^ cx   N     Clear cx
97  XOR  dx <^ dx   N     Clear dx

----------------------------------------------
98-9F -- Reserved

----------------------------------------------
XCHG a, b -> Exchange Values
 C++  swap(a, b);

Reserved Opcode Range: /4 (16 insn)
 
Op  Mm   Args       AddB  Notes
A0  XCHG ax <> ax   N     Debug
A1  XCHG ax <> bx   N
A2  XCHG ax <> cx   N
A3  XCHG ax <> dx   N
A4  XCHG bx <> ax   N
A5  XCHG bx <> bx   N     Debug
A6  XCHG bx <> cx   N
A7  XCHG bx <> dx   N
A8  XCHG cx <> ax   N
A9  XCHG cx <> bx   N
AA  XCHG cx <> cx   N     Debug
AB  XCHG cx <> dx   N
AC  XCHG dx <> ax   N
AD  XCHG dx <> bx   N
AE  XCHG cx <> cx   N
AF  XCHG dx <> dx   N     Debug

----------------------------------------------
Opcodes not listed here (B0-FF) are all reserved.
If they are called, an Invalid Instruction trap
is triggered.
